---
title: "Lecture 4: EDA, Functions and Control Structures"
subtitle: "Intro to Data Science for Public Policy, Spring 2016"
author: "by Jeff Chen & Dan Hammer, Georgetown University McCourt School of Public Policy"
output: 
  html_document: 
    theme: journal
    toc: yes
---


Much of data science requires developing specialized code to handle the eccentricities of a dataset. Re-running blocks of code is required, often times on multiple data samples and subpopulations. It's simply not scalable to manually change variables and assumptions of the code everytime. In this lecture, we will extend EDA by writing custom functions and using control structures. 

##Functions
Functions are generalizable sets of code that can be used to calculate a single value, process an entire dataset, print graphs, among other things. A strong software engineering habit involves building narrowly defined functions and low-level functions that can be put together to do high-level tasks. 

A typical function is constructed as follows. The function name is assigned, followed by a list of parameters that will be used as inputs into the function, followed by the script that will be executed using the input parameters. 

```{r, eval=FALSE}
function.name <- function(parameter1, parameter2){
  #Script goes here
  return([output goes here])
}
```

####Example: Mean
The `mean()` method is a pre-built function that accepts a vector `vec`, sums all values in `vec`, divides by the length of `vec`, then returns the result that is passed through `return()`. 

```{r}
#Create dataset
  df <- data.frame(id = 1:100,
                   value = rnorm(100,10,10),
                   group = round(runif(100)*3))

#Function
  mean2 <- function(vec){
      res <- sum(vec)/length(vec)
      return(res)
  }

#Example
  mean2(df$value)
```

##Control Structures
Variables are typically treated differently based on their quality and characteristics. In order to accomplish analytical and programming tasks, control structures are used to determine how a program will treat a given variable given conditions and parameters. In this section, we will cover two commonly used control structures: if...else statements and for loops.

###If and If...Else Statement
If statements evaluate a logical statement, then execute a script based on whether the evaluated statement is true or false. If the statement is `TRUE`, then the code block is executed.

```{r}
budget <- 450
if(budget > 400){
  #If statement true, run script goes here
  print("You're over budget. Cut back.")
}
```

In cases where there are two or more choices, if...else statements would be appropriate. In addition to the `if()` statement, an `else` statement is included to handle cases where the logical statement is `FALSE`.


```{r, eval=FALSE}
budget <- 399  
if(budget >= 400){
  #If statement true, run script goes here
  print("You're over budget. Cut back.")
} else {
  #else, run script goes here
  print("You're under budget, but watch it.")
}
```

The complexity of these statements can be as simple as `if(x > 10){ print("Hello")}` more complex trees:

```{r}
age <- 23
  
if(age <= 12){
    print("kid")
  } else if(age >12 && age <20) {
    print("teenager")
  } else if(age >=20 && age <65) {
    print("adult")
  } else{
    print("senior")
  }
```


###For-loops
Loops can be used to run the same statement of code multiple times for a list or index of values. Each iteration uses the same code, but may change certain parameters. 

Let's take the following example. The code block essentially says "print values  1 through 5", where `i` is an *index value*. When executing the statement, R will push the first value in the sequence of 1:5 into the index (in this case, it's the number 1), then the code block in between the `{}` (curly brackets) will be executed, treating `i` as if it's the number 1. Upon executing the code without error, R will advance to the next value in the sequence and repeat the process until all values in the sequence have been completed.

```{r}
for(i in 1:5){
  print(i)
}
```

We can do the same for a vector or list of values. In the example below, the vector `news` contains six terms. Using a for-loop, we can print out each word in the vector.

```{r}
news <- c("The","Dow","Is","Up","By","400pts")
for(i in news){
  print(i)
}
```

###What can you do with loops?
Loops are a critical part of all parts of data science, enabling data cleaning, optimization, and automation. Loops are helpful when an function cannot be applied globally, meaning that each element, column, observation or iteration needs to be done on its own. For example, taking the sum of a random variable `x` can be done without looping as R is designed to operate with column-wise functionality. However, a moving average of 10 records would require a forloop.

####Example: EIA Gasoline Spot Price Data
What if we had a time series dataset with a fair amount of random variability and swings in volume? This sounds very much like financial and economic data -- it's often filled with noise. Let's take the [US Energy Information Administration's]() spot price data, specifically the retail [gasoline data](http://www.eia.gov/dnav/pet/xls/PET_PRI_SPT_S1_D.xls). 

```{r, message=FALSE, warning=FALSE}

#Call library to open XLS
  library(gdata)

#Read in data
  df <- read.xls("http://www.eia.gov/dnav/pet/xls/PET_PRI_SPT_S1_D.xls", sheet = 2, skip=2, header = TRUE)

#Inspect and clean up date
  head(df,3)
  df <- df[1000:2000,1:3] 
  colnames(df) <- c("date","ny.values","us.gulf.values")
  df$date <- as.Date(as.character(df$date), "%b %d, %Y")

#Plot the data
  library(ggplot2)
  ggplot(df, aes(date,ny.values)) + geom_line()
```

To smooth the series `ny.values` using a simple moving average, we can do the following:

```{r, message=FALSE, warning=FALSE, fig.height = 3}
size <- 14 #variable used to select window size
df$new <- NA
#Loop range from *size* to number of rows *nrow(df)* minus *size*
for(i in size:nrow(df)){
  
    #Extract values of *x* from positions i-size to i
    extract <- df$ny.values[(i-size):i]
    
    #Calculate mean of *extract*, store to the ith value of *new*
    df$new[i] <- mean(extract)
}
  
#Plot result
 ggplot(df, aes(date,ny.values)) + geom_line(colour="grey") +
    geom_line(data = df, aes(x=date, y=new))

```

It's also possible to use loops within loops. What if we wanted to compare multiple window sizes, we can *nest* one loop inside another. In this case, looping through different potential window sizes helps with identifying the optimal window size.

```{r, message=FALSE, warning=FALSE}
#Vector of windows to be tested
  windows <- c(7, 14, 28, 84)

#Outer loop (index value = *size*)
for(size in windows){
  df$new <- NA
  
  #inner loop (index value = *i*)
  for(i in size:nrow(df)){
      extract <- df$ny.values[(i-size):i]
      df$new[i] <- mean(extract)
  }

  #Calculate correlation
    cor_val <- round(cor(df$new, df$ny.values, use="complete.obs"),2)
  
  #Plot graph
  g <- ggplot(df, aes(date,ny.values)) + 
        geom_line(colour="grey") +
        geom_line(data = df, aes(x=date, y=new)) + 
        ggtitle( paste("rho =", cor_val))
  assign(paste0("g",size), g)
}
  
#Compare
  library(gridExtra)
  grid.arrange(g7, g14, g28, g84, ncol=2)
```

Note that there are some pre-canned functions that can assist with smoothing; However, coding the function from scratch will provide you with greater flexibility to tackle the task at hand.


